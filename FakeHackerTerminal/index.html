<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fake Hacker Terminal</title>
    <style>
        :root {
            --hacker-green: #00ff00;
            --hacker-dark: #0a0a0a;
            --hacker-gray: #1a1a1a;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background-color: var(--hacker-dark);
            color: var(--hacker-green);
            line-height: 1.4;
            padding: 10px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel {
            background-color: var(--hacker-gray);
            border: 1px solid var(--hacker-green);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            position: relative;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 5px var(--hacker-green);
            font-size: 1.3rem;
        }
        
        textarea {
            background-color: #111;
            color: var(--hacker-green);
            border: 1px solid var(--hacker-green);
            border-radius: 5px;
            padding: 10px;
            min-height: 100px;
            font-size: 14px;
            resize: vertical;
            width: 100%;
            margin-bottom: 12px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 12px 0;
        }
        
        button {
            background-color: var(--hacker-dark);
            color: var(--hacker-green);
            border: 1px solid var(--hacker-green);
            border-radius: 5px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 100px;
            font-weight: bold;
            font-size: 12px;
        }
        
        button:hover {
            background-color: var(--hacker-green);
            color: var(--hacker-dark);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .terminal {
            background-color: #000;
            border: 1px solid var(--hacker-green);
            border-radius: 5px;
            padding: 10px;
            height: 250px;
            overflow-y: auto;
            font-size: 14px;
            margin-bottom: 12px;
            position: relative;
            line-height: 1.3;
        }
        
        .terminal-line {
            margin-bottom: 6px;
            white-space: pre-wrap;
            min-height: 16px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .typing {
            border-right: 2px solid var(--hacker-green);
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { border-color: var(--hacker-green); }
            50% { border-color: transparent; }
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 11px;
        }
        
        .progress-bar {
            height: 5px;
            background-color: #333;
            border-radius: 3px;
            margin: 8px 0;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: var(--hacker-green);
            width: 0%;
            transition: width 0.3s;
        }
        
        .download-section {
            text-align: center;
            margin: 15px 0;
        }
        
        .hidden {
            display: none;
        }
        
        .recording {
            background-color: #ff0000 !important;
            color: white !important;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .video-preview {
            margin: 12px 0;
            text-align: center;
        }
        
        .video-preview video {
            max-width: 100%;
            max-height: 400px;
            border: 2px solid var(--hacker-green);
            border-radius: 5px;
        }
        
        .hacker-icon {
            text-align: center;
            font-size: 20px;
            margin: 8px 0;
        }
        
        .success-message {
            color: #00ff00;
            text-align: center;
            margin: 8px 0;
            font-weight: bold;
            font-size: 12px;
        }

        .quality-info {
            color: #888;
            font-size: 11px;
            text-align: center;
            margin: 4px 0;
        }

        .shorts-optimized {
            color: #ff4444;
            font-weight: bold;
            text-align: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .special-effect {
            color: #ffff00 !important;
            text-shadow: 0 0 10px currentColor;
        }

        .emoji-effect {
            animation: bounce 0.5s infinite alternate;
        }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-3px); }
        }

        .vertical-video {
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }

        .effects-controls {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .effect-btn {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .effect-btn.active {
            background: #0f0;
            color: #000;
        }

        .speed-info {
            color: #888;
            font-size: 11px;
            text-align: center;
            margin: 4px 0;
        }

        @media (min-width: 768px) {
            .container {
                max-width: 400px;
            }
            
            .terminal {
                font-size: 15px;
                height: 300px;
            }

            .video-preview video {
                max-height: 500px;
            }
        }

        #recordCanvas {
            position: fixed;
            top: -1000px;
            left: -1000px;
        }

        #backgroundCanvas {
            position: fixed;
            top: -1000px;
            left: -1000px;
        }

        .text-wrap {
            word-break: break-word;
            overflow-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h1>üëæ –§–ï–ô–ö –•–ê–ö–ï–† üëæ</h1>
            <div class="hacker-icon">üíªüî•üë®‚Äçüíª</div>
            <div class="shorts-optimized">üé¨ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–û –î–õ–Ø SHORTS/REELS</div>
            
            <textarea id="hackerText" class="text-wrap">–í–ö–õ–Æ–ß–ê–Æ –•–ê–ö–ï–†–°–ö–ò–ô –†–ï–ñ–ò–ú...
–ò–©–£ –ü–ê–†–û–õ–¨ –û–¢ –ú–ê–ú–ò–ù–û–ì–û –†–û–£–¢–ï–†–ê...
–ù–ê–®–ï–õ: "12345678" üòÇ
–ó–ê–•–û–î–Æ –í –ò–ù–°–¢–ê–ì–†–ê–ú –°–û–°–ï–î–ê...
–í–ò–ñ–£ –ï–ì–û –§–û–¢–ö–ò –° –ö–û–¢–ò–ö–ê–ú–ò...
–î–û–ë–ê–í–õ–Ø–Æ –ö–û–¢–ò–ö–£ –°–í–ï–†–•–°–ü–û–°–û–ë–ù–û–°–¢–ò...
–ü–£–ë–õ–ò–ö–£–Æ –§–û–¢–ö–£ –ö–û–¢–ê-–ù–ò–ù–î–ó–Ø...
–°–û–°–ï–î –í –®–û–ö–ï! ü§Ø
–£–î–ê–õ–Ø–Æ –ò–°–¢–û–†–ò–Æ –ü–û–ò–°–ö–ê...
–ú–ò–°–°–ò–Ø –í–´–ü–û–õ–ù–ï–ù–ê!
–•–ê–ö–ï–† –ú–û–†–û–ñ–ï–ù–û–ï –°–™–ï–î–ï–ù–û! üç¶</textarea>
            
            <div class="effects-controls">
                <button class="effect-btn active" data-effect="matrix">–ú–∞—Ç—Ä–∏—Ü–∞</button>
                <button class="effect-btn" data-effect="hexagon">–•–µ–∫—Å–∞–≥–æ–Ω—ã</button>
                <button class="effect-btn" data-effect="circuit">–°—Ö–µ–º—ã</button>
                <button class="effect-btn" data-effect="glitch">–ì–ª–∏—Ç—á</button>
                <button class="effect-btn" data-effect="rain">–ö–æ–¥-–¥–æ–∂–¥—å</button>
            </div>
            
            <div class="controls">
                <button id="previewBtn">–ü–†–ï–í–¨–Æ</button>
                <button id="recordBtn">–ó–ê–ü–ò–°–ê–¢–¨ SHORTS</button>
                <button id="clearBtn">–û–ß–ò–°–¢–ò–¢–¨</button>
            </div>
            
            <div class="status-bar">
                <span>–°–¢–ê–¢–£–°: <span id="status">–ì–æ—Ç–æ–≤</span></span>
                <span>–í–†–ï–ú–Ø: <span id="time">00:00</span></span>
            </div>
            
            <div class="progress-bar">
                <div class="progress" id="progress"></div>
            </div>

            <div class="quality-info">üé• –§–æ—Ä–º–∞—Ç: 1080x1920 ‚Ä¢ 60 FPS ‚Ä¢ –•–∞–∫–µ—Ä—Å–∫–∏–µ —ç—Ñ—Ñ–µ–∫—Ç—ã</div>
            <div class="speed-info">‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: 20 —Å–µ–∫—É–Ω–¥ ‚Ä¢ –ê–≤—Ç–æ-—Å–∫–æ—Ä–æ—Å—Ç—å</div>
            <div class="success-message" id="successMessage"></div>
        </div>
        
        <div class="panel">
            <h2>–¢–ï–†–ú–ò–ù–ê–õ –•–ê–ö–ï–†–ê</h2>
            <div class="terminal" id="terminal">
                <div class="terminal-line">hacker@root:~# <span id="commandLine" class="typing"></span></div>
                <div id="terminalOutput"></div>
            </div>
            
            <div class="download-section">
                <button id="downloadBtn" class="hidden">üì• –°–ö–ê–ß–ê–¢–¨ SHORTS</button>
                <div class="video-preview vertical-video">
                    <video id="videoPreview" controls class="hidden"></video>
                </div>
                <div class="controls">
                    <button id="tiktokBtn">üéµ TikTok</button>
                    <button id="instagramBtn">üì∑ Instagram</button>
                    <button id="youtubeBtn">‚ñ∂Ô∏è YouTube Shorts</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id="recordCanvas" class="hidden"></canvas>
    <canvas id="backgroundCanvas" class="hidden"></canvas>

    <script>
        class HackerTerminal {
            constructor() {
                this.recorder = null;
                this.isRecording = false;
                this.seconds = 0;
                this.timerInterval = null;
                this.canvas = document.getElementById('recordCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.bgCanvas = document.getElementById('backgroundCanvas');
                this.bgCtx = this.bgCanvas.getContext('2d');
                this.recordedChunks = [];
                this.currentLineIndex = 0;
                this.currentCharIndex = 0;
                this.lines = [];
                this.isTyping = false;
                this.optimalFontSize = 36;
                this.currentEffect = 'matrix';
                this.glitchActive = false;
                this.effects = {};
                this.totalAnimationTime = 20000; // 20 —Å–µ–∫—É–Ω–¥ –æ–±—â–µ–µ –≤—Ä–µ–º—è
                this.charDelay = 0;
                this.lineDelay = 0;
                
                this.initializeElements();
                this.bindEvents();
                this.initializeEffects();
                this.calculateSpeed(); // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å —Å—Ä–∞–∑—É
            }

            initializeElements() {
                this.hackerText = document.getElementById('hackerText');
                this.previewBtn = document.getElementById('previewBtn');
                this.recordBtn = document.getElementById('recordBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.terminalOutput = document.getElementById('terminalOutput');
                this.terminal = document.getElementById('terminal');
                this.commandLine = document.getElementById('commandLine');
                this.status = document.getElementById('status');
                this.time = document.getElementById('time');
                this.progress = document.getElementById('progress');
                this.videoPreview = document.getElementById('videoPreview');
                this.tiktokBtn = document.getElementById('tiktokBtn');
                this.instagramBtn = document.getElementById('instagramBtn');
                this.youtubeBtn = document.getElementById('youtubeBtn');
                this.successMessage = document.getElementById('successMessage');
                this.effectBtns = document.querySelectorAll('.effect-btn');
            }

            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–æ–¥ 20 —Å–µ–∫—É–Ω–¥
            calculateSpeed() {
                const text = this.hackerText.value;
                const lines = text.split('\n');
                
                // –°—á–∏—Ç–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤
                let totalChars = 0;
                lines.forEach(line => {
                    totalChars += line.length;
                });
                
                // –í—ã—á–∏—Ç–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –ø–∞—É–∑—ã –º–µ–∂–¥—É —Å—Ç—Ä–æ–∫–∞–º–∏ (500ms –Ω–∞ –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É)
                const linePausesTime = (lines.length - 1) * 500;
                const typingTime = this.totalAnimationTime - linePausesTime - 1000; // -1 —Å–µ–∫ –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω—É—é –ø–∞—É–∑—É
                
                // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∞–º–∏
                this.charDelay = Math.max(20, Math.min(200, typingTime / totalChars));
                this.lineDelay = 500; // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É —Å—Ç—Ä–æ–∫–∞–º–∏
                
                console.log('Total chars:', totalChars, 'Char delay:', this.charDelay, 'Line delay:', this.lineDelay);
            }

            bindEvents() {
                this.previewBtn.addEventListener('click', () => {
                    this.calculateSpeed(); // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–∏ –∫–∞–∂–¥–æ–º –ø—Ä–µ–≤—å—é
                    this.startTypingAnimation(this.hackerText.value);
                });

                this.recordBtn.addEventListener('click', () => {
                    if (!this.isRecording) {
                        this.startRecording();
                    } else {
                        this.stopRecording();
                    }
                });

                this.clearBtn.addEventListener('click', () => {
                    this.clearTerminal();
                });

                this.downloadBtn.addEventListener('click', () => {
                    this.downloadVideo();
                });

                this.tiktokBtn.addEventListener('click', () => {
                    alert('üéµ –ò–¥–µ–∞–ª—å–Ω–æ –¥–ª—è TikTok! –•–µ—à—Ç–µ–≥: #—Ñ–µ–π–∫—Ö–∞–∫–µ—Ä #—Ö–∞–∫–µ—Ä');
                });

                this.instagramBtn.addEventListener('click', () => {
                    alert('üì∑ –ò–¥–µ–∞–ª—å–Ω–æ –¥–ª—è Instagram Reels! –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç 9:16');
                });

                this.youtubeBtn.addEventListener('click', () => {
                    alert('‚ñ∂Ô∏è –ò–¥–µ–∞–ª—å–Ω–æ –¥–ª—è YouTube Shorts! –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–æ 60 —Å–µ–∫—É–Ω–¥');
                });

                this.effectBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.effectBtns.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentEffect = btn.dataset.effect;
                    });
                });

                // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞
                this.hackerText.addEventListener('input', () => {
                    this.calculateSpeed();
                });
            }

            initializeEffects() {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–æ–Ω–æ–≤–æ–≥–æ canvas
                this.bgCanvas.width = 1080;
                this.bgCanvas.height = 1920;

                // –£–ù–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–ê–Ø –°–ö–û–†–û–°–¢–¨ –î–õ–Ø –í–°–ï–• –≠–§–§–ï–ö–¢–û–í
                const unifiedSpeed = 1.0; // –ë–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å

                // –≠—Ñ—Ñ–µ–∫—Ç –ú–∞—Ç—Ä–∏—Ü—ã
                this.effects.matrix = {
                    chars: "010101010101„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥",
                    fontSize: 14,
                    columns: 0,
                    drops: [],
                    speed: unifiedSpeed,
                    init: () => {
                        this.effects.matrix.columns = Math.floor(this.bgCanvas.width / this.effects.matrix.fontSize);
                        this.effects.matrix.drops = Array(this.effects.matrix.columns).fill(1);
                    },
                    draw: () => {
                        this.bgCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                        this.bgCtx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                        
                        this.bgCtx.fillStyle = '#0F0';
                        this.bgCtx.font = this.effects.matrix.fontSize + 'px monospace';
                        
                        for (let i = 0; i < this.effects.matrix.drops.length; i++) {
                            const text = this.effects.matrix.chars[Math.floor(Math.random() * this.effects.matrix.chars.length)];
                            this.bgCtx.fillText(text, i * this.effects.matrix.fontSize, this.effects.matrix.drops[i] * this.effects.matrix.fontSize);
                            
                            if (this.effects.matrix.drops[i] * this.effects.matrix.fontSize > this.bgCanvas.height && Math.random() > 0.975) {
                                this.effects.matrix.drops[i] = 0;
                            }
                            this.effects.matrix.drops[i] += this.effects.matrix.speed;
                        }
                    }
                };

                // –≠—Ñ—Ñ–µ–∫—Ç –•–µ–∫—Å–∞–≥–æ–Ω–æ–≤
                this.effects.hexagon = {
                    hexagons: [],
                    speed: unifiedSpeed,
                    init: () => {
                        this.effects.hexagon.hexagons = [];
                        for (let i = 0; i < 50; i++) {
                            this.effects.hexagon.hexagons.push({
                                x: Math.random() * this.bgCanvas.width,
                                y: Math.random() * this.bgCanvas.height,
                                size: 20 + Math.random() * 40,
                                speed: (0.2 + Math.random() * 0.8) * this.effects.hexagon.speed,
                                opacity: 0.1 + Math.random() * 0.3
                            });
                        }
                    },
                    draw: () => {
                        this.bgCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        this.bgCtx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                        
                        this.effects.hexagon.hexagons.forEach(hex => {
                            this.bgCtx.strokeStyle = `rgba(0, 255, 0, ${hex.opacity})`;
                            this.bgCtx.lineWidth = 2;
                            this.bgCtx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * 2 * Math.PI) / 6;
                                const x = hex.x + hex.size * Math.cos(angle);
                                const y = hex.y + hex.size * Math.sin(angle);
                                if (i === 0) this.bgCtx.moveTo(x, y);
                                else this.bgCtx.lineTo(x, y);
                            }
                            this.bgCtx.closePath();
                            this.bgCtx.stroke();
                            
                            hex.y += hex.speed;
                            if (hex.y > this.bgCanvas.height + hex.size) {
                                hex.y = -hex.size;
                            }
                        });
                    }
                };

                // –≠—Ñ—Ñ–µ–∫—Ç –°—Ö–µ–º
                this.effects.circuit = {
                    nodes: [],
                    connections: [],
                    speed: unifiedSpeed,
                    init: () => {
                        this.effects.circuit.nodes = [];
                        this.effects.circuit.connections = [];
                        
                        for (let i = 0; i < 30; i++) {
                            this.effects.circuit.nodes.push({
                                x: Math.random() * this.bgCanvas.width,
                                y: Math.random() * this.bgCanvas.height,
                                pulse: Math.random() * Math.PI * 2
                            });
                        }
                        
                        for (let i = 0; i < this.effects.circuit.nodes.length; i++) {
                            for (let j = i + 1; j < this.effects.circuit.nodes.length; j++) {
                                const dx = this.effects.circuit.nodes[i].x - this.effects.circuit.nodes[j].x;
                                const dy = this.effects.circuit.nodes[i].y - this.effects.circuit.nodes[j].y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 200) {
                                    this.effects.circuit.connections.push({ from: i, to: j });
                                }
                            }
                        }
                    },
                    draw: () => {
                        this.bgCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        this.bgCtx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                        
                        this.effects.circuit.connections.forEach(conn => {
                            const from = this.effects.circuit.nodes[conn.from];
                            const to = this.effects.circuit.nodes[conn.to];
                            const pulse = (Math.sin(from.pulse) + 1) / 2;
                            
                            this.bgCtx.strokeStyle = `rgba(0, 255, 0, ${0.2 + pulse * 0.3})`;
                            this.bgCtx.lineWidth = 1;
                            this.bgCtx.beginPath();
                            this.bgCtx.moveTo(from.x, from.y);
                            this.bgCtx.lineTo(to.x, to.y);
                            this.bgCtx.stroke();
                        });
                        
                        this.effects.circuit.nodes.forEach(node => {
                            node.pulse += 0.05 * this.effects.circuit.speed;
                            const size = 3 + Math.sin(node.pulse) * 2;
                            
                            this.bgCtx.fillStyle = '#0F0';
                            this.bgCtx.beginPath();
                            this.bgCtx.arc(node.x, node.y, size, 0, Math.PI * 2);
                            this.bgCtx.fill();
                        });
                    }
                };

                // –≠—Ñ—Ñ–µ–∫—Ç –ö–æ–¥-–¥–æ–∂–¥—è
                this.effects.rain = {
                    drops: [],
                    speed: unifiedSpeed,
                    init: () => {
                        this.effects.rain.drops = [];
                        for (let i = 0; i < 100; i++) {
                            this.effects.rain.drops.push({
                                x: Math.random() * this.bgCanvas.width,
                                y: Math.random() * this.bgCanvas.height,
                                speed: (2 + Math.random() * 8) * this.effects.rain.speed,
                                length: 5 + Math.floor(Math.random() * 20),
                                chars: '01010101'
                            });
                        }
                    },
                    draw: () => {
                        this.bgCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        this.bgCtx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                        
                        this.bgCtx.font = '14px monospace';
                        this.effects.rain.drops.forEach(drop => {
                            for (let i = 0; i < drop.length; i++) {
                                const opacity = 1 - (i / drop.length);
                                this.bgCtx.fillStyle = `rgba(0, 255, 0, ${opacity})`;
                                const char = drop.chars[Math.floor(Math.random() * drop.chars.length)];
                                this.bgCtx.fillText(char, drop.x, drop.y - i * 14);
                            }
                            
                            drop.y += drop.speed;
                            if (drop.y > this.bgCanvas.height + drop.length * 14) {
                                drop.y = -drop.length * 14;
                                drop.x = Math.random() * this.bgCanvas.width;
                            }
                        });
                    }
                };

                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
                Object.values(this.effects).forEach(effect => effect.init());
            }

            startTypingAnimation(text) {
                if (this.isTyping) return;
                
                this.clearTerminal();
                this.lines = text.split('\n');
                this.currentLineIndex = 0;
                this.currentCharIndex = 0;
                this.isTyping = true;
                
                this.typeNextCharacter();
            }

            typeNextCharacter() {
                if (this.currentLineIndex >= this.lines.length) {
                    this.isTyping = false;
                    this.status.textContent = '–ó–∞–≤–µ—Ä—à–µ–Ω–æ!';
                    return;
                }

                const currentLine = this.lines[this.currentLineIndex];
                
                if (this.currentCharIndex === 0) {
                    this.currentLineElement = document.createElement('div');
                    this.currentLineElement.className = 'terminal-line text-wrap';
                    this.terminalOutput.appendChild(this.currentLineElement);
                }

                if (this.currentCharIndex < currentLine.length) {
                    const char = currentLine[this.currentCharIndex];
                    this.currentLineElement.textContent += char;
                    this.currentCharIndex++;
                    
                    this.terminal.scrollTop = this.terminal.scrollHeight;
                    
                    const totalChars = this.lines.reduce((sum, line) => sum + line.length, 0);
                    const typedChars = this.lines.slice(0, this.currentLineIndex).reduce((sum, line) => sum + line.length, 0) + this.currentCharIndex;
                    this.progress.style.width = `${(typedChars / totalChars) * 100}%`;
                    
                    // ‚ö° –ò–°–ü–û–õ–¨–ó–£–ï–ú –†–ê–°–°–ß–ò–¢–ê–ù–ù–£–Æ –°–ö–û–†–û–°–¢–¨ –î–õ–Ø 20 –°–ï–ö–£–ù–î
                    const delay = this.charDelay;
                    
                    setTimeout(() => {
                        this.typeNextCharacter();
                    }, delay);
                } else {
                    this.addSpecialEffects(this.currentLineElement, currentLine);
                    this.currentLineIndex++;
                    this.currentCharIndex = 0;
                    
                    // ‚ö° –ò–°–ü–û–õ–¨–ó–£–ï–ú –†–ê–°–°–ß–ò–¢–ê–ù–ù–£–Æ –ü–ê–£–ó–£ –ú–ï–ñ–î–£ –°–¢–†–û–ö–ê–ú–ò
                    setTimeout(() => {
                        this.typeNextCharacter();
                    }, this.lineDelay);
                }
            }

            addSpecialEffects(lineElement, text) {
                if (text.includes('üòÇ') || text.includes('üç¶')) {
                    lineElement.classList.add('special-effect');
                    this.addEmojiEffect(lineElement);
                } else if (text.includes('ü§Ø')) {
                    lineElement.style.color = '#ff00ff';
                    lineElement.style.textShadow = '0 0 15px #ff00ff';
                } else if (text.includes('–ù–ê–®–ï–õ') || text.includes('–°–û–°–ï–î')) {
                    lineElement.style.color = '#00ffff';
                    lineElement.style.textShadow = '0 0 10px #00ffff';
                }
            }

            addEmojiEffect(lineElement) {
                const emojis = lineElement.textContent.match(/[üòÇü§Øüç¶]/g);
                if (emojis) {
                    let html = lineElement.textContent;
                    emojis.forEach(emoji => {
                        html = html.replace(emoji, `<span class="emoji-effect">${emoji}</span>`);
                    });
                    lineElement.innerHTML = html;
                }
            }

            calculateOptimalFontSize(lines) {
                const maxWidth = 900;
                const maxHeight = 1500;
                let fontSize = 42;
                
                this.ctx.font = `bold ${fontSize}px "Courier New", monospace`;
                
                for (let size = fontSize; size > 20; size -= 2) {
                    this.ctx.font = `bold ${size}px "Courier New", monospace`;
                    let totalHeight = 100;
                    let fits = true;
                    
                    lines.forEach(line => {
                        const words = line.split(' ');
                        let currentLine = '';
                        
                        for (let word of words) {
                            const testLine = currentLine + word + ' ';
                            const metrics = this.ctx.measureText(testLine);
                            
                            if (metrics.width > maxWidth) {
                                if (currentLine !== '') {
                                    totalHeight += 45;
                                    currentLine = word + ' ';
                                }
                            } else {
                                currentLine = testLine;
                            }
                        }
                        
                        if (currentLine !== '') {
                            totalHeight += 45;
                        }
                    });
                    
                    if (totalHeight <= maxHeight) {
                        return size;
                    }
                }
                
                return 24;
            }

            applyGlitchEffect() {
                if (this.currentEffect === 'glitch' && Math.random() < 0.3) {
                    const shiftX = (Math.random() - 0.5) * 20;
                    const shiftY = (Math.random() - 0.5) * 10;
                    
                    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.putImageData(imageData, shiftX, shiftY);
                    
                    if (Math.random() < 0.2) {
                        this.ctx.fillStyle = `rgba(255, 0, 255, ${Math.random() * 0.3})`;
                        this.ctx.fillRect(
                            Math.random() * this.canvas.width,
                            Math.random() * this.canvas.height,
                            Math.random() * 100,
                            Math.random() * 10
                        );
                    }
                }
            }

            async startRecording() {
                try {
                    this.isRecording = true;
                    this.recordBtn.textContent = '–°–¢–û–ü –ó–ê–ü–ò–°–ò';
                    this.recordBtn.classList.add('recording');
                    this.status.textContent = '–ó–∞–ø–∏—Å—å Shorts...';
                    this.recordedChunks = [];
                    
                    // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –ø–µ—Ä–µ–¥ –∑–∞–ø–∏—Å—å—é
                    this.calculateSpeed();
                    
                    this.canvas.width = 1080;
                    this.canvas.height = 1920;
                    
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    
                    const text = this.hackerText.value;
                    const lines = text.split('\n');
                    this.optimalFontSize = this.calculateOptimalFontSize(lines);

                    const stream = this.canvas.captureStream(60);
                    const options = {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 6000000
                    };

                    this.recorder = new MediaRecorder(stream, options);

                    this.recorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };

                    this.recorder.onstop = () => {
                        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                        this.recordedBlob = blob;
                        const url = URL.createObjectURL(blob);
                        this.videoPreview.src = url;
                        this.videoPreview.classList.remove('hidden');
                        this.downloadBtn.classList.remove('hidden');
                        
                        this.successMessage.textContent = '‚úÖ Shorts –≤–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!';
                    };

                    this.recorder.start(100);
                    this.startTimer();

                    this.startTypingAnimation(text);
                    
                    this.renderTerminalToCanvas();
                    const renderInterval = setInterval(() => {
                        if (this.isRecording) {
                            this.renderTerminalToCanvas();
                        } else {
                            clearInterval(renderInterval);
                        }
                    }, 16);

                    // –ê–≤—Ç–æ—Å—Ç–æ–ø —á–µ—Ä–µ–∑ 20 —Å–µ–∫—É–Ω–¥
                    setTimeout(() => {
                        if (this.isRecording) {
                            this.stopRecording();
                        }
                    }, this.totalAnimationTime);

                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏:', error);
                    this.handleRecordingError();
                }
            }

            renderTerminalToCanvas() {
                // –û—á–∏—â–∞–µ–º canvas
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // –†–∏—Å—É–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ñ–æ–Ω
                if (this.effects[this.currentEffect]) {
                    this.effects[this.currentEffect].draw();
                    this.ctx.drawImage(this.bgCanvas, 0, 0);
                }
                
                // –†–∏—Å—É–µ–º —Ç–µ—Ä–º–∏–Ω–∞–ª —Å –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ñ–æ–Ω–æ–º
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(50, 50, this.canvas.width - 100, this.canvas.height - 100);
                
                // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
                this.ctx.font = `bold ${this.optimalFontSize}px "Courier New", monospace`;
                this.ctx.textBaseline = 'top';
                
                const lines = this.terminalOutput.querySelectorAll('.terminal-line');
                let y = 120;
                const lineHeight = this.optimalFontSize + 10;
                const maxWidth = 900;
                const leftMargin = (this.canvas.width - maxWidth) / 2;
                
                // –†–µ–Ω–¥–µ—Ä–∏–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillText('hacker@root:~# ', leftMargin, y);
                
                // –†–µ–Ω–¥–µ—Ä–∏–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏
                lines.forEach(line => {
                    y += lineHeight;
                    const color = line.style.color || '#00ff00';
                    this.ctx.fillStyle = color;
                    
                    const text = line.textContent;
                    let words = text.split(' ');
                    let currentLine = '';
                    let currentY = y;
                    
                    for (let i = 0; i < words.length; i++) {
                        const testLine = currentLine + words[i] + ' ';
                        const metrics = this.ctx.measureText(testLine);
                        
                        if (metrics.width > maxWidth && currentLine !== '') {
                            this.ctx.fillText(currentLine, leftMargin, currentY);
                            currentLine = words[i] + ' ';
                            currentY += lineHeight;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    
                    if (currentLine !== '') {
                        this.ctx.fillText(currentLine.trim(), leftMargin, currentY);
                    }
                    
                    y = currentY;
                });
                
                // –†–µ–Ω–¥–µ—Ä–∏–º –∫—É—Ä—Å–æ—Ä
                if (this.isTyping) {
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.fillRect(leftMargin + this.ctx.measureText('hacker@root:~# ').width, 120, 6, this.optimalFontSize);
                }

                // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥–ª–∏—Ç—á —ç—Ñ—Ñ–µ–∫—Ç
                this.applyGlitchEffect();

                // –í–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫
                this.ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                this.ctx.font = `bold ${Math.max(20, this.optimalFontSize - 10)}px "Courier New", monospace`;
                const watermark = '@FAKE_HACKER_TERMINAL';
                const watermarkWidth = this.ctx.measureText(watermark).width;
                this.ctx.fillText(watermark, (this.canvas.width - watermarkWidth) / 2, 1850);
            }

            stopRecording() {
                if (this.recorder && this.isRecording) {
                    this.recorder.stop();
                    this.isRecording = false;
                    this.recordBtn.textContent = '–ó–ê–ü–ò–°–ê–¢–¨ SHORTS';
                    this.recordBtn.classList.remove('recording');
                    this.status.textContent = '–ó–∞–ø–∏—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
                    this.stopTimer();
                    this.isTyping = false;
                    
                    setTimeout(() => {
                        const celebration = document.createElement('div');
                        celebration.className = 'terminal-line special-effect';
                        celebration.textContent = '>>> SHORTS –í–ò–î–ï–û –ì–û–¢–û–í–û! üé¨';
                        this.terminalOutput.appendChild(celebration);
                        this.terminal.scrollTop = this.terminal.scrollHeight;
                    }, 500);
                }
            }

            downloadVideo() {
                if (this.recordedBlob) {
                    const url = URL.createObjectURL(this.recordedBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hacker-shorts-${new Date().getTime()}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    this.successMessage.textContent = 'üì• Shorts –≤–∏–¥–µ–æ —Å–∫–∞—á–∏–≤–∞–µ—Ç—Å—è!';
                    
                    setTimeout(() => {
                        this.successMessage.textContent = '‚úÖ –ì–æ—Ç–æ–≤–æ –¥–ª—è —Å–æ—Ü—Å–µ—Ç–µ–π!';
                    }, 2000);
                }
            }

            clearTerminal() {
                this.terminalOutput.innerHTML = '';
                this.status.textContent = '–ì–æ—Ç–æ–≤';
                this.time.textContent = '00:00';
                this.progress.style.width = '0%';
                this.stopTimer();
                this.seconds = 0;
                this.downloadBtn.classList.add('hidden');
                this.videoPreview.classList.add('hidden');
                this.successMessage.textContent = '';
                this.isTyping = false;
            }

            handleRecordingError() {
                this.status.textContent = '–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏';
                this.isRecording = false;
                this.recordBtn.textContent = '–ó–ê–ü–ò–°–ê–¢–¨ SHORTS';
                this.recordBtn.classList.remove('recording');
                this.successMessage.textContent = '‚ùå –û—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ Chrome –±—Ä–∞—É–∑–µ—Ä.';
            }

            startTimer() {
                this.seconds = 0;
                this.updateTimer();
                this.timerInterval = setInterval(() => {
                    this.seconds++;
                    this.updateTimer();
                }, 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            updateTimer() {
                const minutes = Math.floor(this.seconds / 60);
                const remainingSeconds = this.seconds % 60;
                this.time.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new HackerTerminal();
        });
    </script>
</body>
</html>